<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>å³æ™‚æŠ•å½±</title>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script src="https://unpkg.com/simple-peer@9.11.1/simplepeer.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.5/socket.io.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');

        html {
            -webkit-overflow-scrolling: touch;
        }

        body {
            font-family: 'Inter', 'Noto Sans TC', sans-serif;
        }

        video {
            width: 100%;
            height: auto;
            display: block;
        }

        /* Vue éå ´å‹•ç•« */
        .fade-enter-active, .fade-leave-active {
            transition: opacity 0.3s ease;
        }

        .fade-enter-from, .fade-leave-to {
            opacity: 0;
        }

        .slide-up-enter-active, .slide-up-leave-active {
            transition: all 0.35s cubic-bezier(0.16, 1, 0.3, 1);
        }

        .slide-up-enter-from, .slide-up-leave-to {
            transform: translateY(20px);
            opacity: 0;
        }
    </style>
</head>
<body class="bg-gradient-to-br from-slate-50 via-blue-50 to-indigo-50 min-h-screen text-gray-800">
<div id="app" class="flex flex-col min-h-screen">
    <header class="text-center py-8 px-4 shrink-0">
        <h1 class="text-4xl font-bold mb-2">å³æ™‚æŠ•å½±</h1>
        <p class="text-gray-600 text-lg">ä½ è¦çœ‹çš„ï¼Œéƒ½è®“ä½ çœ‹</p>
    </header>

    <main class="max-w-4xl w-full mx-auto px-4 pb-8 flex-grow">
        <transition name="fade" mode="out-in">
            <div v-if="view === 'home'" key="home"
                 class="bg-white/80 backdrop-blur-xl rounded-2xl p-8 shadow-xl border border-white/30">
                <h2 class="text-2xl font-semibold mb-6 text-center">è«‹é¸æ“‡ä½¿ç”¨æ¨¡å¼</h2>
                <div class="grid md:grid-cols-2 gap-6">
                    <div class="bg-white p-6 rounded-xl shadow-sm hover:shadow-lg transition-all duration-300 cursor-pointer border-2 border-transparent hover:border-blue-400 hover:-translate-y-1"
                         @click="startAsCamera">
                        <div class="text-center">
                            <div class="text-6xl mb-4">ğŸ“±</div>
                            <h3 class="text-xl font-semibold mb-2">ç•¶ä½œæ”å½±æ©Ÿ</h3>
                            <p class="text-gray-600 text-sm">è‡ªå‹•ç”¢ç”Ÿæˆ¿è™Ÿï¼Œä¸¦é–‹å§‹æ‹æ”</p>
                        </div>
                    </div>
                    <div class="bg-white p-6 rounded-xl shadow-sm hover:shadow-lg transition-all duration-300 cursor-pointer border-2 border-transparent hover:border-indigo-400 hover:-translate-y-1"
                         @click="startAsDisplay">
                        <div class="text-center">
                            <div class="text-6xl mb-4">ğŸ–¥ï¸</div>
                            <h3 class="text-xl font-semibold mb-2">ç•¶ä½œé¡¯ç¤ºç«¯</h3>
                            <p class="text-gray-600 text-sm">è¼¸å…¥æˆ¿è™Ÿï¼Œæ¥æ”¶ä¸¦é¡¯ç¤ºå½±åƒ</p>
                        </div>
                    </div>
                </div>
            </div>

            <div v-else-if="view === 'displayInput'" key="display-input"
                 class="bg-white/80 backdrop-blur-xl rounded-2xl p-8 shadow-xl border border-white/30">
                <div class="max-w-xs mx-auto">
                    <div class="mb-4">
                        <label for="room-input" class="block text-sm font-medium text-gray-700 mb-2">è«‹è¼¸å…¥ 4
                            ä½æ•¸æˆ¿é–“è™Ÿç¢¼</label>
                        <input id="room-input" v-model="inputRoomId" type="text" inputmode="numeric" pattern="[0-9]*"
                               placeholder="1234" maxlength="4"
                               class="w-full px-4 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:border-transparent outline-none transition-all text-center text-3xl tracking-[0.2em] font-mono shadow-sm"/>
                    </div>
                    <div class="flex flex-col sm:flex-row-reverse gap-3">
                        <button @click="connectAsDisplay" :disabled="!(/^\d{4}$/.test(inputRoomId)) || isConnecting"
                                class="w-full disabled:opacity-50 disabled:cursor-not-allowed"
                                :class="primaryBtnClasses">
                            <span v-if="isConnecting">é€£ç·šä¸­...</span><span v-else>é–‹å§‹æ¥æ”¶</span>
                        </button>
                        <button @click="goHome" class="w-full" :class="secondaryBtnClasses">è¿”å›</button>
                    </div>
                </div>
            </div>

            <div v-else-if="view === 'main'" key="main" class="space-y-6">
                <div class="bg-white/80 backdrop-blur-xl rounded-2xl p-4 shadow-xl border border-white/30">
                    <div class="flex flex-wrap items-center justify-between gap-3">
                        <div class="flex items-center gap-3">
                            <span :class="status.indicatorClasses">
                                <span class="w-2.5 h-2.5 rounded-full inline-block mr-2"
                                      :class="status.dotClasses"></span>
                                {{ status.text }}
                            </span>
                        </div>
                        <div class="text-sm text-gray-600 font-mono bg-white/70 px-2 py-1 rounded">
                            æˆ¿è™Ÿï¼š<span class="font-semibold text-indigo-600">{{ roomId }}</span>
                        </div>
                    </div>
                </div>

                <div v-if="isCamera"
                     class="bg-white/80 backdrop-blur-xl rounded-2xl p-6 shadow-xl border border-white/30 space-y-4">

                    <div class="p-4 bg-indigo-50 border border-dashed border-indigo-200 rounded-lg text-center">
                        <strong @click="copyShareUrl"
                                title="é»æ“Šä»¥è¤‡è£½é€£çµ"
                                class="text-4xl font-mono tracking-widest block my-2 py-2 cursor-pointer transition-all duration-200 rounded-lg hover:bg-indigo-100 active:scale-95">
                            {{ roomId }}
                        </strong>
                    </div>

                    <div class="text-center">
                        <button v-if="canShare" @click="shareViaWeb" :class="secondaryBtnClasses"
                                class="inline-flex items-center gap-2 px-4" title="åˆ†äº«">
                            ğŸ”—
                            <span>ä½¿ç”¨ç³»çµ±åˆ†äº«</span>
                        </button>
                    </div>

                    <div v-if="!hasRemoteConnection" class="text-center text-gray-500 animate-pulse pt-2">
                        ç­‰å¾…é¡¯ç¤ºç«¯é€£ç·š...
                    </div>
                    <div v-else class="text-center text-green-600 font-semibold pt-2">é¡¯ç¤ºç«¯å·²é€£ç·šï¼</div>
                </div>

                <div class="bg-white/80 backdrop-blur-xl rounded-2xl p-4 sm:p-6 shadow-xl border border-white/30">
                    <div v-if="isCamera && localStream" class="max-w-xl mx-auto">
                        <h3 class="text-xl font-semibold text-center mb-4">ğŸ“¹ æœ¬æ©Ÿé è¦½</h3>
                        <div class="rounded-2xl overflow-hidden shadow-lg border-2 border-white bg-gray-900 max-h-[70vh]">
                            <video ref="localVideo" autoplay muted playsinline class="w-full h-full object-contain"></video>
                        </div>
                    </div>
                    <div v-if="isDisplay" class="relative">
                        <div class="rounded-2xl overflow-hidden shadow-lg border-2 border-white bg-gray-900 min-h-[250px] sm:min-h-[400px] flex items-center justify-center max-h-[75vh]">
                            <video ref="remoteVideo" autoplay playsinline
                                   :class="{ 'hidden': !hasRemoteStream }"
                                   class="w-full h-full object-contain"></video>
                            <div v-if="!hasRemoteStream" class="text-center text-white p-8">
                                <div class="text-6xl mb-4 animate-pulse">ğŸ“º</div>
                                <h4 class="text-xl font-semibold">ç­‰å¾…æ”å½±æ©Ÿä¸²æµ...</h4>
                            </div>
                        </div>
                    </div>
                    <div class="flex justify-center gap-4 mt-6">
                        <button v-if="isCamera" @click="switchCamera" :class="secondaryBtnClasses">ğŸ”„ åˆ‡æ›é¡é ­</button>
                        <button v-if="isDisplay" @click="toggleFullscreen" :class="secondaryBtnClasses">ğŸ–¼ï¸ å…¨è¢å¹•
                        </button>
                        <button @click="disconnect" :class="dangerBtnClasses">ğŸ›‘ çµæŸé€£ç·š</button>
                    </div>
                </div>
            </div>
        </transition>

        <div class="fixed bottom-6 left-1/2 -translate-x-1/2 w-11/12 max-w-md z-50 space-y-3">
            <transition name="slide-up">
                <div v-if="errorMessage"
                     class="bg-red-100 border border-red-300 text-red-800 px-4 py-3 rounded-xl shadow-lg flex items-center gap-3">
                    <span class="text-xl">âš ï¸</span>
                    <p class="flex-grow">{{ errorMessage }}</p>
                    <button @click="errorMessage = ''" class="text-red-500 text-2xl leading-none">&times;</button>
                </div>
            </transition>
            <transition name="slide-up">
                <div v-if="successMessage"
                     class="bg-green-100 border border-green-300 text-green-800 px-4 py-3 rounded-xl shadow-lg flex items-center gap-3">
                    <span class="text-xl">âœ…</span>
                    <p class="flex-grow">{{ successMessage }}</p>
                    <button @click="successMessage = ''" class="text-green-500 text-2xl leading-none">&times;</button>
                </div>
            </transition>
        </div>
    </main>
</div>

<script>
    const {createApp, ref, computed, onMounted, onUnmounted, nextTick} = Vue;

    // --- çµ„æ…‹è¨­å®š ---
    const SIGNALING_SERVER_URL = 'wss://api-project.xinshou.tw'; // æ›¿æ›ç‚ºæ‚¨çš„ WebSocket ä¼ºæœå™¨åœ°å€

    createApp({
        setup() {
            // --- ç‹€æ…‹ç®¡ç† (State) ---
            const view = ref('home'); // 'home', 'displayInput', 'main'
            const role = ref(null); // 'camera', 'display'
            const roomId = ref('');
            const inputRoomId = ref('');
            const isConnecting = ref(false);
            const isConnected = ref(false);
            const hasRemoteStream = ref(false);
            const hasRemoteConnection = ref(false);
            const errorMessage = ref('');
            const successMessage = ref('');
            const currentCamera = ref('environment'); // å„ªå…ˆä½¿ç”¨å¾Œç½®é¡é ­ 'environment'

            const socket = ref(null);
            const peer = ref(null);
            const localStream = ref(null);

            const localVideo = ref(null);
            const remoteVideo = ref(null);

            // --- è¨ˆç®—å±¬æ€§ (Computed) ---
            const isCamera = computed(() => role.value === 'camera');
            const isDisplay = computed(() => role.value === 'display');
            const shareUrl = computed(() => `${window.location.origin}${window.location.pathname}?room=${roomId.value}`);
            const canShare = computed(() => !!navigator.share);

            const status = computed(() => {
                if (isConnected.value) {
                    if (isCamera.value && !hasRemoteConnection.value) return {
                        text: 'ç­‰å¾…é€£ç·š',
                        // indicatorClasses: 'bg-yellow-100 text-yellow-800',
                        dotClasses: 'bg-yellow-500 animate-pulse'
                    };
                    if (isDisplay.value && !hasRemoteStream.value) return {
                        text: 'ç­‰å¾…ä¸²æµ',
                        // indicatorClasses: 'bg-yellow-100 text-yellow-800',
                        dotClasses: 'bg-yellow-500 animate-pulse'
                    };
                    return {
                        text: 'å·²é€£ç·š',
                        // indicatorClasses: 'bg-green-100 text-green-800',
                        dotClasses: 'bg-green-500'
                    };
                }
                if (isConnecting.value) return {
                    text: 'é€£ç·šä¸­...',
                    // indicatorClasses: 'bg-blue-100 text-blue-800',
                    dotClasses: 'bg-blue-500 animate-spin'
                };
                return {
                    text: 'æœªé€£ç·š',
                    // indicatorClasses: 'bg-red-100 text-red-800',
                    dotClasses: 'bg-red-500'
                };
            });

            // --- UI Class æ¨£å¼ (çµ±ä¸€ç®¡ç†) ---
            const baseBtnClasses = 'font-semibold py-2 px-5 rounded-lg shadow-md hover:shadow-lg transform hover:-translate-y-0.5 transition-all duration-200 focus:outline-none focus:ring-4';
            const primaryBtnClasses = computed(() => `${baseBtnClasses} bg-gradient-to-r from-blue-500 to-indigo-600 text-white focus:ring-blue-300`);
            const secondaryBtnClasses = computed(() => `${baseBtnClasses} bg-white hover:bg-gray-100 text-gray-800 border border-gray-200 focus:ring-gray-200`);
            const dangerBtnClasses = computed(() => `${baseBtnClasses} bg-red-500 hover:bg-red-600 text-white focus:ring-red-300`);

            // --- æ–¹æ³• (Methods) ---
            const showMessage = (msg, type = 'error', duration = 4000) => {
                if (type === 'error') {
                    errorMessage.value = msg;
                    setTimeout(() => errorMessage.value = '', duration);
                } else {
                    successMessage.value = msg;
                    setTimeout(() => successMessage.value = '', duration);
                }
            };

            const cleanup = () => {
                if (localStream.value) localStream.value.getTracks().forEach(track => track.stop());
                if (peer.value) peer.value.destroy();
                if (socket.value) socket.value.disconnect();
                localStream.value = peer.value = socket.value = null;
                isConnected.value = hasRemoteStream.value = hasRemoteConnection.value = false;
            };

            const goHome = () => {
                cleanup();
                view.value = 'home';
                role.value = null;
                roomId.value = inputRoomId.value = '';
            };

            const disconnect = () => goHome();

            const startAsCamera = async () => {
                role.value = 'camera';
                roomId.value = Math.floor(1000 + Math.random() * 9000).toString();
                view.value = 'main';
                await connect();
            };

            const startAsDisplay = () => {
                role.value = 'display';
                view.value = 'displayInput';
            };

            const connectAsDisplay = async () => {
                if (inputRoomId.value.length !== 4) return;
                roomId.value = inputRoomId.value;
                view.value = 'main';
                await connect();
            };

            const connect = async () => {
                if (isConnecting.value || isConnected.value) return;
                isConnecting.value = true;

                try {
                    if (isCamera.value) await initCamera();
                    await initSocket();
                    socket.value.emit('join-room', roomId.value);
                    isConnected.value = true;
                } catch (error) {
                    showMessage(`é€£ç·šå¤±æ•—: ${error.message}`);
                    goHome();
                } finally {
                    isConnecting.value = false;
                }
            };

            const initCamera = async () => {
                try {
                    const constraints = {
                        video: {
                            facingMode: currentCamera.value,
                            width: {ideal: 1280},
                            height: {ideal: 720}
                        }, audio: false
                    };
                    localStream.value = await navigator.mediaDevices.getUserMedia(constraints);
                    await nextTick();
                    if (localVideo.value) localVideo.value.srcObject = localStream.value;
                } catch (error) {
                    console.error('Camera init error:', error);
                    throw new Error('ç„¡æ³•è¨ªå•æ”å½±æ©Ÿï¼Œè«‹ç¢ºèªå·²æˆæ¬Šã€‚');
                }
            };

            const initSocket = () => {
                return new Promise((resolve, reject) => {
                    // ... socket é€£ç·šéƒ¨åˆ†ä¸è®Š ...
                    socket.value = io(SIGNALING_SERVER_URL, {reconnectionAttempts: 3});
                    socket.value.on('connect', () => {
                        console.log('Socket connected:', socket.value.id);
                        resolve();
                    });
                    socket.value.on('connect_error', () => reject(new Error('ç„¡æ³•é€£æ¥åˆ°ä¼ºæœå™¨')));

                    // ç•¶æœ‰æ–°ç”¨æˆ¶åŠ å…¥æ™‚ï¼Œæ”å½±æ©Ÿç«¯æœƒæ”¶åˆ°æ­¤è¨Šæ¯
                    socket.value.on('user-joined', (data) => {
                        if (isCamera.value) {
                            initiateCall(data.userId); // æ”å½±æ©Ÿç™¼èµ·å‘¼å«
                        }
                    });

                    socket.value.on('room-full', (data) => {
                        // é¡¯ç¤ºéŒ¯èª¤è¨Šæ¯çµ¦ä½¿ç”¨è€…
                        showMessage('é€£ç·šå¤±æ•—ï¼šè©²æˆ¿é–“å·²æ»¿å“¡ï¼');
                        // å¯ä»¥é¸æ“‡ç›´æ¥å°‡ä½¿ç”¨è€…å°å›é¦–é 
                        goHome();
                        // æ‹’çµ• Promiseï¼Œä¸­æ–·é€£ç·šæµç¨‹
                        reject(new Error('Room is full.'));
                    });

                    // ã€æ–°å¢ã€‘é¡¯ç¤ºç«¯ç›£è½ä¾†è‡ªæ”å½±æ©Ÿçš„ Offer
                    socket.value.on('offer-received', (data) => {
                        if (isDisplay.value) {
                            receiveCall(data.signal); // é¡¯ç¤ºç«¯æ¥æ”¶å‘¼å«ä¸¦å»ºç«‹ peer
                        }
                    });

                    // ã€ç¶­æŒã€‘ç”¨æ–¼æ¥æ”¶å¾ŒçºŒçš„ Answer æˆ– ICE ä¿¡ä»¤
                    socket.value.on('signal', (data) => {
                        if (peer.value && !peer.value.destroyed) {
                            peer.value.signal(data.signal);
                        }
                    });

                    socket.value.on('user-left', () => {
                        showMessage('å°æ–¹å·²é›¢ç·š', 'error');
                        hasRemoteConnection.value = false;
                        hasRemoteStream.value = false;
                        if (peer.value) {
                            peer.value.destroy();
                            peer.value = null;
                        }
                    });
                });
            };

            const setupPeerListeners = (p) => {
                p.on('signal', (signalData) => {
                    // å°‡ 'signal' æ”¹ç‚º 'forward-signal'
                    socket.value.emit('forward-signal', {signal: signalData});
                });
                // ... å…¶ä»–ç›£è½å™¨ä¸è®Š ...
                p.on('connect', () => hasRemoteConnection.value = true);
                p.on('stream', (stream) => {
                    hasRemoteStream.value = true;
                    if (remoteVideo.value) remoteVideo.value.srcObject = stream;
                });
                p.on('close', () => hasRemoteConnection.value = false);
                p.on('error', (err) => showMessage(`P2Pé€£ç·šéŒ¯èª¤: ${err.message}`));
            };
            const initiateCall = (targetUserId) => {
                if (peer.value) peer.value.destroy();
                peer.value = new SimplePeer({initiator: true, trickle: false, stream: localStream.value});
                setupPeerListeners(peer.value);
            };

            const receiveCall = (signal) => {
                if (peer.value) peer.value.destroy();
                peer.value = new SimplePeer({initiator: false, trickle: false});
                setupPeerListeners(peer.value);
                peer.value.signal(signal);
            };

            // --- æ§åˆ¶é …æ–¹æ³• ---
            const switchCamera = async () => {
                currentCamera.value = currentCamera.value === 'user' ? 'environment' : 'user';
                try {
                    await initCamera(); // Re-initialize camera with new facing mode
                    if (peer.value && peer.value._pc) {
                        const sender = peer.value._pc.getSenders().find(s => s.track && s.track.kind === 'video');
                        if (sender) await sender.replaceTrack(localStream.value.getVideoTracks()[0]);
                    }
                    showMessage('é¡é ­åˆ‡æ›æˆåŠŸ', 'success');
                } catch (error) {
                    showMessage(`åˆ‡æ›é¡é ­å¤±æ•—: ${error.message}`);
                }
            };

            const toggleFullscreen = () => {
                if (!remoteVideo.value) return;
                if (!document.fullscreenElement) remoteVideo.value.requestFullscreen().catch(err => showMessage(`ç„¡æ³•é€²å…¥å…¨è¢å¹•: ${err.message}`));
                else document.exitFullscreen();
            };

            const copyShareUrl = async () => {
                try {
                    await navigator.clipboard.writeText(shareUrl.value);
                    showMessage('é€£çµå·²è¤‡è£½åˆ°å‰ªè²¼ç°¿', 'success');
                } catch (err) {
                    showMessage('è¤‡è£½å¤±æ•—ï¼Œæ‚¨çš„ç€è¦½å™¨å¯èƒ½ä¸æ”¯æ´æ­¤åŠŸèƒ½ã€‚');
                }
            };

            const shareViaWeb = () => navigator.share({title: 'æ‰‹æ©Ÿé¡é ­å³æ™‚æŠ•å½±', url: shareUrl.value});

            // --- ç”Ÿå‘½é€±æœŸ (Lifecycle) ---
            onMounted(() => {
                const urlParams = new URLSearchParams(window.location.search);
                const roomFromUrl = urlParams.get('room');
                if (roomFromUrl && /^\d{4}$/.test(roomFromUrl)) {
                    inputRoomId.value = roomFromUrl;
                    startAsDisplay();
                    connectAsDisplay();
                }
            });
            onUnmounted(() => cleanup());

            return {
                view,
                role,
                isCamera,
                isDisplay,
                roomId,
                inputRoomId,
                isConnecting,
                isConnected,
                hasRemoteStream,
                hasRemoteConnection,
                errorMessage,
                successMessage,
                shareUrl,
                canShare,
                status,
                primaryBtnClasses,
                secondaryBtnClasses,
                dangerBtnClasses,
                localVideo,
                remoteVideo,
                localStream,
                startAsCamera,
                startAsDisplay,
                connectAsDisplay,
                goHome,
                disconnect,
                switchCamera,
                toggleFullscreen,
                copyShareUrl,
                shareViaWeb,
            };
        }
    }).mount('#app');
</script>
</body>
</html>